package net.sf.jncu.fdil;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;

import net.sf.jncu.protocol.IDockCommand;
import net.sf.jncu.protocol.v1_0.data.DEntry;
import net.sf.jncu.protocol.v2_0.DockCommandFactory;
import net.sf.junit.SFTestCase;

import org.junit.Test;

/**
 * <pre>
 * x := {name: "Walter Smith",
 *       cats: 2,
 *       bounds: {left: 10, top: 14, right: 40, bottom: 100},
 *       right: $\u2022,
 *       phones: ["408-996-1010", nil]};
 * x.phones[1] := SetClass("408-974-9094", 'faxPhone);
 * x.nameAgain := x.name;
 * </pre>
 * 
 * <pre>
 * { name: "Walter Smith",
 *       cats: 2,
 *       bounds: {left: 10, top: 14, right: 40, bottom: 100},
 *       uchar: $\u2022,
 *       phones: ["408-996-1010", <faxPhone, length 26>],
 *       nameAgain: "Walter Smith"}
 * </pre>
 * 
 * <br>
 * The streamed representation of this frame is:<br>
 * <tt>02060607046E616D650704636174730706626F756E6473070575636861720706<br>
 * 70686F6E657307096E616D65416761696E081A00570061006C00740065007200<br>
 * 200053006D006900740068000000080B0E0A64280220220502081A0034003000<br>
 * 38002D003900390036002D00310030003100300000031A070866617850686F6E<br>
 * 65003400300038002D003900370034002D003900300039003400000907</tt>
 * <p>
 * This streamed representation translates as:
 * 
 * <pre>
 * 02�version number
 * 06�kFrame [ID 0]
 * 06�length, 6 slots
 * Slot tags:
 *    07 (kSymbol) 04 (length of name) 6E616D65 ("name") [ID 1]
 *    07 04 63617473 ("cats") [ID 2]
 *    07 06 626F756E6473 ("bounds") [ID 3]
 *    07 05 7563686172 ("uchar") [ID 4]
 *    07 06 70686F6E6573 ("phones") [ID 5]
 *    07 09 6E616D65416761696E ("nameAgain") [ID 6]
 * Slot values:
 *    08�kString [ID 7]
 *    1A�length, 26 bytes
 *    00570061006C00740065007200200053006D0069007400680000 ("Walter Smith")
 *    00�kImmediate
 *    08�Ref of the integer 2
 *    0B�kSmallRect [ID 8]
 *       0E (top=14) 0A (left=10) 64 (bottom=100) 28 (right=40)
 *       02�kUnicodeCharacter
 *       2022�The character code
 *       05�kPlainArray [ID 9]
 *       02�length, 2 slots
 *    Slot values:
 *       08�kString [ID 10]
 *       1A�length, 26 bytes
 *       003400300038002D003900390036002D00310030003100300000 ("408-996-1010")
 *       03�kBinaryObject [ID 11]
 *       1A�length, 26 bytes
 *       Class:
 *          07(kSymbol) 08 (length of name) 66617850686F6E65 ("faxPhone")[ID 12]
 *       003400300038002D003900370034002D00390030003900340000 ("408-974-9094")
 *    09�kPrecedent
 *    07�ID 7 ("Walter Smith" object above)
 * </pre>
 * 
 * @author moshew
 */
public class NSOFExample extends SFTestCase {

	private static final byte[] NSOF_FRAME = { 0x02, 0x06, 0x06, 0x07, 0x04, 0x6E, 0x61, 0x6D, 0x65, 0x07, 0x04, 0x63, 0x61, 0x74, 0x73, 0x07, 0x06, 0x62, 0x6F, 0x75, 0x6E, 0x64,
			0x73, 0x07, 0x05, 0x75, 0x63, 0x68, 0x61, 0x72, 0x07, 0x06, 0x70, 0x68, 0x6F, 0x6E, 0x65, 0x73, 0x07, 0x09, 0x6E, 0x61, 0x6D, 0x65, 0x41, 0x67, 0x61, 0x69, 0x6E, 0x08,
			0x1A, 0x00, 0x57, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x20, 0x00, 0x53, 0x00, 0x6D, 0x00, 0x69, 0x00, 0x74, 0x00, 0x68, 0x00, 0x00, 0x00,
			0x08, 0x0B, 0x0E, 0x0A, 0x64, 0x28, 0x02, 0x20, 0x22, 0x05, 0x02, 0x08, 0x1A, 0x00, 0x34, 0x00, 0x30, 0x00, 0x38, 0x00, 0x2D, 0x00, 0x39, 0x00, 0x39, 0x00, 0x36, 0x00,
			0x2D, 0x00, 0x31, 0x00, 0x30, 0x00, 0x31, 0x00, 0x30, 0x00, 0x00, 0x03, 0x1A, 0x07, 0x08, 0x66, 0x61, 0x78, 0x50, 0x68, 0x6F, 0x6E, 0x65, 0x00, 0x34, 0x00, 0x30, 0x00,
			0x38, 0x00, 0x2D, 0x00, 0x39, 0x00, 0x37, 0x00, 0x34, 0x00, 0x2D, 0x00, 0x39, 0x00, 0x30, 0x00, 0x39, 0x00, 0x34, 0x00, 0x00, 0x09, 0x07 };

	/**
	 * Creates a new test case.
	 */
	public NSOFExample() {
		super();
	}

	/**
	 * Test encoding.
	 * 
	 * @throws Exception
	 */
	@Test
	public void testEncode() throws Exception {
		NSOFObject[] phones = new NSOFObject[] { new NSOFString("408-996-1010"), null };
		NSOFBinaryObject faxPhone = new NSOFBinaryObject();
		faxPhone.setObjectClass("faxPhone");
		byte[] utf16 = "408-974-9094".getBytes("UTF-16");
		System.arraycopy(utf16, 2, utf16, 0, utf16.length - 2);
		utf16[utf16.length - 2] = 0;
		utf16[utf16.length - 1] = 0;
		faxPhone.setValue(utf16);
		phones[1] = faxPhone;

		NSOFFrame x = new NSOFFrame();
		assertNotNull(x);
		x.put("name", new NSOFString("Walter Smith"));
		x.put("cats", new NSOFInteger(2));
		x.put("bounds", new NSOFSmallRect(14, 10, 100, 40));
		x.put("uchar", new NSOFUnicodeCharacter('\u2022'));
		x.put("phones", new NSOFPlainArray(phones));
		x.put("nameAgain", x.get("name"));
		assertEquals(6, x.size());
		assertNotNull(x.get("name"));
		assertNotNull(x.get("cats"));
		assertNotNull(x.get("bounds"));
		assertNotNull(x.get("uchar"));
		assertNotNull(x.get("phones"));
		assertEquals("Walter Smith", ((NSOFString) x.get("name")).getValue());

		ByteArrayOutputStream out = new ByteArrayOutputStream();
		NSOFEncoder encoder = new NSOFEncoder();
		encoder.flatten(x, out);
		out.close();

		byte[] buf = out.toByteArray();
		// print(buf);
		assertNotNull(buf);
		assertEquals(NSOF_FRAME, buf);
	}

	/**
	 * Test decoding.
	 * 
	 * @throws Exception
	 */
	@Test
	public void testDecode() throws Exception {
		InputStream in = new ByteArrayInputStream(NSOF_FRAME);
		NSOFDecoder decoder = new NSOFDecoder();
		NSOFObject o = decoder.inflate(in);
		assertNotNull(o);
		assertTrue(o instanceof NSOFFrame);
		NSOFFrame x = (NSOFFrame) o;
		assertEquals(6, x.size());
		assertNotNull(x.get("name"));
		assertNotNull(x.get("cats"));
		assertNotNull(x.get("bounds"));
		assertNotNull(x.get("uchar"));
		assertNotNull(x.get("phones"));
		assertNotNull(x.get("nameAgain"));
		assertSame(x.get("name"), x.get("nameAgain"));

		// TODO implement me!
	}

	protected void print(byte[] arr) {
		byte b;
		String hex;
		int col = 1;

		for (int i = 0; i < arr.length; i++, col++) {
			b = arr[i];
			hex = Integer.toHexString(b & 0xFF).toUpperCase();
			if (b < 0x10) {
				System.out.print('0');
			}
			System.out.print(hex);
			if (col == 32) {
				System.out.println();
				col = 0;
			}
		}
	}

	private static final byte[] REPEAT_ENTRY_33 = { 0x6e, 0x65, 0x77, 0x74, 0x64, 0x6f, 0x63, 0x6b, 0x65, 0x6e, 0x74, 0x72, 0x00, 0x00, 0x01, (byte) 0xba, 0x02, 0x06, 0x11, 0x07,
			0x0c, 0x6d, 0x74, 0x67, 0x53, 0x74, 0x61, 0x72, 0x74, 0x44, 0x61, 0x74, 0x65, 0x07, 0x11, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x4e, 0x6f, 0x74, 0x65, 0x73,
			0x44, 0x61, 0x74, 0x61, 0x07, 0x05, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x07, 0x09, 0x4e, 0x6f, 0x74, 0x65, 0x73, 0x44, 0x61, 0x74, 0x61, 0x07, 0x07, 0x6d, 0x74, 0x67, 0x54,
			0x65, 0x78, 0x74, 0x07, 0x0a, 0x76, 0x69, 0x65, 0x77, 0x42, 0x6f, 0x75, 0x6e, 0x64, 0x73, 0x07, 0x0e, 0x76, 0x69, 0x65, 0x77, 0x53, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e,
			0x65, 0x72, 0x79, 0x07, 0x0a, 0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0x54, 0x79, 0x70, 0x65, 0x07, 0x0b, 0x6d, 0x74, 0x67, 0x53, 0x74, 0x6f, 0x70, 0x44, 0x61, 0x74, 0x65,
			0x07, 0x07, 0x6d, 0x74, 0x67, 0x49, 0x6e, 0x66, 0x6f, 0x07, 0x0b, 0x6d, 0x74, 0x67, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x07, 0x0a, 0x65, 0x78, 0x63, 0x65,
			0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x07, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x07, 0x0b, 0x6d, 0x74, 0x67, 0x49, 0x63, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65,
			0x07, 0x08, 0x6d, 0x74, 0x67, 0x41, 0x6c, 0x61, 0x72, 0x6d, 0x07, 0x09, 0x5f, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x44, 0x07, 0x08, 0x5f, 0x6d, 0x6f, 0x64, 0x54,
			0x69, 0x6d, 0x65, 0x00, (byte) 0xff, 0x0b, (byte) 0xd2, (byte) 0x9a, 0x00, 0x0a, 0x07, 0x07, 0x6d, 0x65, 0x65, 0x74, 0x69, 0x6e, 0x67, 0x0a, 0x08, 0x16, 0x00, 0x66,
			0x00, 0x61, 0x00, 0x6d, 0x00, 0x69, 0x00, 0x6c, 0x00, 0x79, 0x00, 0x20, 0x00, 0x64, 0x00, 0x61, 0x00, 0x79, 0x00, 0x00, 0x0a, 0x07, 0x08, 0x63, 0x72, 0x69, 0x62, 0x4e,
			0x6f, 0x74, 0x65, 0x00, 0x0c, 0x00, (byte) 0xff, 0x0b, (byte) 0xf3, 0x1e, (byte) 0xfc, 0x00, (byte) 0xff, 0x00, 0x00, 0x10, 0x34, 0x00, 0x00, 0x05, 0x01, 0x05, 0x02,
			0x00, (byte) 0xff, 0x0b, (byte) 0xf2, (byte) 0xae, (byte) 0x80, 0x06, 0x06, 0x09, 0x01, 0x09, 0x03, 0x09, 0x06, 0x09, 0x07, 0x07, 0x0a, 0x6f, 0x72, 0x69, 0x67, 0x69,
			0x6e, 0x44, 0x61, 0x74, 0x65, 0x07, 0x0e, 0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x00, (byte) 0xff, 0x0b, (byte) 0xf3,
			0x08, (byte) 0x80, 0x09, 0x12, 0x0a, 0x09, 0x14, 0x00, (byte) 0xff, 0x0b, (byte) 0xf2, (byte) 0xae, (byte) 0x80, 0x06, 0x11, 0x09, 0x01, 0x09, 0x02, 0x09, 0x03, 0x09,
			0x04, 0x09, 0x05, 0x09, 0x06, 0x09, 0x11, 0x09, 0x07, 0x09, 0x08, 0x09, 0x09, 0x09, 0x0a, 0x09, 0x0b, 0x09, 0x0c, 0x09, 0x0d, 0x09, 0x0e, 0x09, 0x10, 0x09, 0x0f, 0x00,
			(byte) 0xff, 0x0b, (byte) 0xd2, (byte) 0x9a, 0x00, 0x0a, 0x09, 0x12, 0x0a, 0x09, 0x13, 0x0a, 0x00, (byte) 0xff, 0x0c, 0x12, (byte) 0xec, 0x78, 0x09, 0x14, 0x00, 0x0c,
			0x00, (byte) 0xff, 0x0b, (byte) 0xf3, 0x1e, (byte) 0xfc, 0x00, (byte) 0xff, 0x00, 0x00, 0x10, 0x34, 0x00, 0x00, 0x09, 0x15, 0x00, 0x08, 0x07, 0x0b, 0x61, 0x6e, 0x6e,
			0x75, 0x61, 0x6c, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x00, (byte) 0xac, 0x0a, 0x00, 0x08, 0x09, 0x1b, 0x0a, 0x00, (byte) 0x80, 0x00, (byte) 0xff, 0x0d, 0x0a, (byte) 0xab,
			(byte) 0xb4, 0x00, 0x00 };

	/**
	 * Test infinite recursion of a frame with an array with the same frame.
	 * 
	 * @throws Exception
	 */
	public void testInfiniteRecursion() throws Exception {
		assertNotNull(REPEAT_ENTRY_33);
		assertEquals(IDockCommand.COMMAND_HEADER_LENGTH + 442 + 2, REPEAT_ENTRY_33.length);

		DockCommandFactory factory = DockCommandFactory.getInstance();
		assertNotNull(factory);
		IDockCommand cmd = factory.deserializeCommand(REPEAT_ENTRY_33);
		assertNotNull(cmd);
		assertEquals(442, cmd.getLength());
		assertTrue(cmd instanceof DEntry);
		DEntry entry = (DEntry) cmd;
		print(entry.getResult(), 0);
		String s = cmd.toString();
		assertNotNull(s);
		assertFalse(s.length() == 0);
	}

	protected void print(NSOFFrame frame, int level) {
		String indent = "";
		for (int i = 0; i < level; i++)
			indent += "\t";
		String indent1 = indent + "\t";
		System.out.print(indent);
		System.out.println('{');
		NSOFObject value;
		for (NSOFSymbol key : frame.getKeys()) {
			System.out.print(indent1);
			value = frame.get(key);
			System.out.print(key.getValue());
			System.out.print('=');
			print(value, level + 1);
		}
		System.out.print(indent);
		System.out.println('}');
	}

	protected void print(NSOFArray array, int level) {
		System.out.println("[]");
	}

	protected void print(NSOFObject object, int level) {
		if (object instanceof NSOFArray) {
			print((NSOFArray) object, level);
			return;
		}
		System.out.println(object.toString());
	}
}
